"use strict";class t{constructor(t,s){this.x=t,this.y=s}toArgs(){return[this.x,this.y]}add({x:s,y:i}){return new t(this.x+s,this.y+i)}sub({x:s,y:i}){return new t(this.x-s,this.y-i)}scale(s){return new t(this.x*s,this.y*s)}rotate(s){return new t(this.x*Math.cos(s)-this.y*Math.sin(s),this.x*Math.sin(s)+this.y*Math.cos(s))}distance({x:t,y:s}){return((this.x-t)**2+(this.y-s)**2)**.5}static intersection({x:s,y:i},{x:e,y:n},{x:o,y:h},{x:r,y:a}){const l=(a-h)*(e-s)-(r-o)*(n-i);if(0===l)return null;const c=((r-o)*(i-h)-(a-h)*(s-o))/l,d=((e-s)*(i-h)-(n-i)*(s-o))/l;return c>=0&&c<=1&&d>=0&&d<=1?new t(s+c*(e-s),i+c*(n-i)):null}}class s extends t{constructor(t,s,i){super(t,s),this.timestamp=i}}const i=[new t(-2.5,-40),new t(-2.5,40),new t(2.5,40),new t(2.5,-40)],e=24,n=.95,o=200;const h=900,r=1600,a=new t(h/2,r/2),l={lineJoin:"round",lineWidth:1};const c=20;const d=120;const u=1.2,p=.2,y=.001,w=1/4200,g=200,f=.01,m=[new t(-100,-10),new t(-100,10),new t(100,10),new t(100,-10)],x=[new t(-90,-15),new t(-90,-10),new t(90,-10),new t(90,-15)];const P=new class{constructor(){this.canvas=canvas,this.canvas.width=h,this.canvas.height=r,this.context=canvas.getContext("2d"),this.width=h,this.height=r,this.camera=new t(0,0)}trackToast(t){this.camera.y=t.position.y}getOffset(){return a.sub(this.camera)}lines([t,...s],i){Object.assign(this.context,l,i);const e=this.getOffset();this.context.beginPath(),this.context.moveTo(...t.add(e).toArgs());for(const t of s)this.context.lineTo(...t.add(e).toArgs());this.context.closePath(),i.fillStyle&&this.context.fill(),i.strokeStyle&&this.context.stroke()}clear(){this.context.clearRect(0,0,h,r)}},b=new class{constructor(s,i=0,e=0){this.display=s,this.position=new t(i,e),this.r=.4,this.dx=.1,this.dy=0,this.dr=.01}draw(){this.drawToast(),this.drawButter()}getTransformedPoints(t){return t.map(t=>t.rotate(this.r).add(this.position))}drawToast(){const t=this.getTransformedPoints(m);this.display.lines(t,{fillStyle:"rgba(195, 134, 68, 1)",strokeStyle:"rgba(195, 134, 68, 1)",lineWidth:3})}drawButter(){const t=this.getTransformedPoints(x);this.display.lines(t,{fillStyle:"rgba(248, 239, 204, 1)",strokeStyle:"rgba(248, 239, 204, 1)",lineWidth:2})}tick(t){this.position.x+=this.dx*t,this.position.y+=this.dy*t,this.r+=this.dr*t;const s=1-t**-Math.E;this.dx*=s,this.dy*=s,this.dr*=s,this.dy=this.dy*(1-p)+u*p}applyForce({x:t,y:s},{x:i,y:e}){this.dx+=i,this.dy+=e,this.dr+=(t*e-s*i)*w}ensureWithinWalls(){Math.abs(this.position.x)>g&&(this.dx+=f*-Math.sign(this.position.x))}tryApplyForce(t){if(null===t)return!1;const[s,i]=t;if(null===this.getIntersection(this.position,s))return!1;const e=this.getIntersection(s,i);if(null===e)return!1;const n=e.sub(s).scale(y),o=e.sub(this.position);return this.applyForce(o,n),!0}getIntersection(s,i){const e=this.getTransformedPoints(m);e.push(e[0]);let n=null;for(let o=0;o<e.length-1;o+=1){const h=t.intersection(s,i,e[o],e[o+1]);if(null!==h){s.distance(h)<1/0&&(n=h)}}return n}}(P);!function({airFlow:t,display:s,gui:i,mouse:e,toast:n}){e.init();let o=0,h=!0;requestAnimationFrame(function i(r){requestAnimationFrame(i);const a=Math.min(r-o,c);o=r,h?h=!1:(s.clear(),n.tick(a),n.ensureWithinWalls(),s.trackToast(n),t.draw(),n.draw(),e.tick(r),e.draw())})}({airFlow:new class{constructor(t,s){this.display=t,this.toast=s,this.pointCache=new Map}drawOne(t,s){this.display.lines(i.map(s=>s.add(t)),{fillStyle:s})}ensurePoint(s){if(!this.pointCache.has(s)){const i=this.display.width*n;this.pointCache.set(s,new t(Math.floor(Math.random()*o)/(o-1)*i-i/2,s*e))}}draw(){this.trimExcess(),this.ensureEnough();const t=`rgba(255, 255, 255, ${this.toast.dy**2*.5})`;for(const s of this.pointCache.values())this.drawOne(s,t)}getMinimumY(){return Math.floor((this.display.camera.y-this.display.height/2)/e)}getNumberOfFittingShapes(){return Math.ceil(this.display.height/e)}trimExcess(){const t=this.getMinimumY();for(const s of this.pointCache.keys())s<t&&this.pointCache.delete(s)}ensureEnough(){const t=this.getMinimumY(),s=t+this.getNumberOfFittingShapes();for(let i=t;i<=s;i+=1)this.ensurePoint(i)}}(P,b),display:P,mouse:new class{constructor(t,s){this.display=t,this.toast=s,this.now=-1/0,this.points=new Set,this.lastPoint=null,this.pressed=!1}start(){this.pressed=!0}clearPoints(){this.points=new Set,this.lastPoint=null}stop(){this.clearPoints(),this.pressed=!1}pushPoint(t){const{left:i,top:e,width:n,height:o}=this.display.canvas.getBoundingClientRect();this.lastPoint=new s((t.clientX-i)*this.display.width/n,(t.clientY-e)*this.display.height/o,this.now),this.points.add(this.lastPoint)}init(){this.display.canvas.addEventListener("mousedown",t=>{t.preventDefault(),this.pressed=!0,this.pushPoint(t)}),this.display.canvas.addEventListener("mousemove",t=>{this.pressed&&this.pushPoint(t)}),window.addEventListener("mouseup",()=>{this.stop()})}getCurrentVector(){if(this.points.size<2||null===this.lastPoint)return null;const t=this.display.getOffset(),[s]=this.points;return[s.sub(t),this.lastPoint.sub(t)]}tick(t){this.now=t,this.pressed&&(this.removeOldPoints(t),this.toast.tryApplyForce(this.getCurrentVector())&&this.clearPoints())}removeOldPoints(t){const s=[];for(const i of this.points)i.timestamp<t-d&&s.push(i);for(const t of s)this.points.delete(t);0===this.points.size&&(this.lastPoint=null)}draw(){if(0===this.points.size)return;const{context:t}=this.display;t.fillStyle="rgba(255, 105, 180, 0.2)",t.strokeStyle="rgba(255, 105, 180, 1)";for(const{x:s,y:i}of this.points)t.beginPath(),t.arc(s,i,5,0,2*Math.PI),t.fill();const s=this.getCurrentVector();if(null!==s){const i=this.display.getOffset(),[e,n]=s;t.beginPath(),t.moveTo(...e.add(i).toArgs()),t.lineTo(...n.add(i).toArgs()),t.stroke()}}}(P,b),toast:b});
